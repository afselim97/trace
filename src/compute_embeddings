#!/usr/bin/env python3
import numpy as np
import pandas as pd
import os
import glob
import argparse
from typing import List
from tqdm import tqdm
import shutil

import demes
import tskit
try:
    import msprime
except:
    print("cannot simulate")

from trasp import *
from mds import *
from utils import *

def calculate_L_list(num_trees:List[int],L:int) -> List[int]:
    """Calculates a list of the number of trees to sample from each tree sequence (representing a chromosome part)
        Draws proportionally larger numbers from larger chromosomes, ensuring total sums to L

    Args:
        num_trees (List[int]): Th enumber of trees in each tree sequence
        L (int): total number of trees desired

    Returns:
        List[int]: The number of trees to be extracted from each tree sequence
    """
    if L is not None:
        proportions = np.array(num_trees) / np.sum(num_trees)
        raw_allocation = proportions * L
        initial_allocation = np.floor(raw_allocation).astype(int)
        remaining = L - np.sum(initial_allocation)
        fractions = raw_allocation - np.floor(raw_allocation)
        indices_sorted_by_fraction = np.argsort(fractions)[::-1]
        for i in range(remaining):
            initial_allocation[indices_sorted_by_fraction[i]] += 1

        final_allocation = initial_allocation
    return final_allocation

def prepare_from_simulation(demes_file_path: str, output_path: str, n: int, L: int):
    """prepares an iterator of tree sequences given a demes file to simulate.

    Args:
        demes_file_path (str): The demography to be simulated in demes format
        n (int): number of haploid samples per population in given demography
        L (int): number of independent trees to simulate

    Returns:
        iterator: an iterator of tree sequences
        List[int]: a list of size L, where each entry is 2 (a single tree is taken from each simulation to ensure total independence)
        int: the total number of samples in the simulation
    """
    if "SS" in demes_file_path: ## simulate only 2 samples per deme for stepping stones models
        n=2
    else:
        graph = demes.load(demes_file_path)
        demes.dump(graph,os.path.join(output_path,"deme.yaml"))
    
    demography = msprime.Demography.from_demes(graph)
    K=0
    samples = {}
    population_samples_dict = {}
    for pop in demography.populations:
        if pop.default_sampling_time == 0:
            samples[pop.name] = n
            population_samples_dict[pop.name] = np.arange(n*K,n*(K+1))
            K+=1
    n_samples = n*K

    ts_list = msprime.sim_ancestry(
        samples = samples,
        demography = demography,
        sequence_length=1,
        ploidy = 1,
        num_replicates = L
        )

    L_list = [1]*L
    
    return ts_list,L_list,n_samples,population_samples_dict

def prepare_from_inference(inferred_trees_dir: str,L: int):
    ts_files = glob.glob(f"{inferred_trees_dir}/*trees")
    num_trees = [tskit.load(ts_file).num_trees for ts_file in tqdm(ts_files)]
    n_samples = tskit.load(ts_files[0]).n_samples
    if L is None:
        L_list = (np.array(num_trees)/n_samples).astype(int)
    else:
        L_list = calculate_L_list(num_trees,L)

    ts_list = (tskit.load(ts_file) for ts_file in ts_files)
    return ts_list,L_list,n_samples

def get_timepoints(min_time: float,max_time: float,num_timepoints: int,log_time: bool,delta: float,node_times):

    if min_time is None:
        min_time = np.quantile(node_times[node_times!=0],0.01)
    
    if max_time is None:
        max_time = np.quantile(node_times[node_times!=0],0.95)

    if log_time:
        t_list = np.logspace(np.log10(min_time),np.log10(max_time),num_timepoints)
    else:
        t_list = np.linspace(min_time,max_time,num_timepoints)
    delta_list = np.array([delta]*num_timepoints)

    return t_list,delta_list

def estimate_delta(node_times,L,average_num_events = 200):
    # Estimates delta based on a rough estimate of Ne from tmrca of trees, such that ~average_num_events trees experience a coalescent event between each two pairs within each delta window
    Ne_estimate = np.mean(node_times[0,:])/2
    delta_estimate = average_num_events * Ne_estimate / L
    return delta_estimate


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("-input", type=str, required=True, help="path to demes file or to directory with inferred trees")    
    parser.add_argument("-output", type=str, required=True, help="output path")
    parser.add_argument("-metadata", type=str, help="path to metadata file. Must include columns with names [population,sample_id]")
    parser.add_argument("-mode", type=str, default="inferred", help="either 'simulated' or 'inferred'.")
    parser.add_argument("-L", type=int, help="number of independent trees to sample or simulate")
    parser.add_argument("-min_time", type=float, help="minimum time to start computing rates and embeddings")
    parser.add_argument("-max_time", type=float, help="maximum time to compute rates and embeddings")
    parser.add_argument("-num_timepoints", type=int, default=100, help="number of timepoints to use")
    parser.add_argument("-delta", type=float, help="the timw width of each window")
    parser.add_argument("-log_time", action="store_true", help="use this flag to have log-spaced time points")

    args = parser.parse_args()
    
    input = args.input
    output = args.output
    metadata = args.metadata
    mode = args.mode
    L = args.L
    min_time = args.min_time
    max_time = args.max_time
    num_timepoints = args.num_timepoints
    delta = args.delta
    log_time = args.log_time

    os.makedirs(output,exist_ok=True)

    if mode == "inferred":
        assert metadata is not None, "for inferred trees, metadata file has to be provided"
        metadata = pd.read_csv(metadata,index_col=0)
        assert np.all(np.in1d(np.array(list(metadata.columns)),np.array(["sample_id","population"]))), "metadata file must have columns ['sample_id','population']"
        population_samples_dict = get_samples_dict(metadata)

    # Preprocess the trees
    assert mode == "inferred" or mode == "simulated", "mode must be 'simulated' or 'inferred'"
    if mode == "simulated":
        if L is None:
            L=10000
        n=50
        ts_list,L_list,n_samples,population_samples_dict = prepare_from_simulation(demes_file_path = input, output_path = output, n=n, L=L)
        shutil.copy(input,output)

        print(f"simulating {L} trees under specified demography")
    elif mode == "inferred":
        print("calculating number of trees to sample from each tree sequence")
        ts_list,L_list,n_samples = prepare_from_inference(inferred_trees_dir =input, L=L)

    # Compute the rates
    trace_instance = trasp(ts_list,L_list,n_samples)
    node_times = trace_instance.node_time_matrix
    if delta is None:
        delta = estimate_delta(node_times,L,average_num_events = 200)
    t_list,delta_list = get_timepoints(min_time,max_time,num_timepoints,log_time,delta,node_times)
    
    print("Estimating pairwise coalescent rates")
    num_uncoalesced_through_time,num_coal_events_within_windows,rates_through_time = trace_instance.compute_coal_rates(t_list, delta_list)

    data_matrix = np.stack((num_uncoalesced_through_time,num_coal_events_within_windows,rates_through_time),axis=3)
    data_df = create_data_df(data_matrix,t_list,delta,population_samples_dict)

    # Compute the embeddings
    print("computing embeddings using MDS")
    embeddings_through_time = compute_embeddings_over_time(rates_through_time)
    embeddings_df = create_embeddings_df(embeddings_through_time,t_list,population_samples_dict)

    # Saving data
    data_df.write_parquet(os.path.join(output,"data.parquet"))
    embeddings_df.write_parquet(os.path.join(output,"embeddings.parquet"))

if __name__ == "__main__":
    main()
